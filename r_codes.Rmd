---
title: "Community Assembly in Alpine Ecosystem"
author: "Luyao Kang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = F}
knitr::opts_chunk$set(
  collapse = T, echo=T, comment="#>", message=F, warning=F,
	fig.align="center", fig.width=5, fig.height=3, dpi=150)
```

# Load libraries
```{r}
setwd('E:/147asvs/')
library(phyloseq)
library(ape)
library(Biostrings)
library(reshape)
library(ggplot2)
```

# Construct phyloseq objects
```{r}
#read in metadata
metadata <- read.delim("./data/metadata.txt", sep = '\t', row.names=1, header = T)
metadata <- sample_data(metadata)

## bacteria
#read in otu table
otu.table <- read.delim('./data/bacteria/otutab_rare.txt',sep="\t", row.names=1, header = T)
otu.table <- as.matrix(otu.table)

#read in taxonomy, seperated by kingdom phylum class order family genus species 
taxonomy <- read.delim('./data/bacteria/taxonomy.txt',sep="\t",row.names=1, header = T)
taxonomy <- as.matrix(taxonomy)

# read in tree
tree <- read_tree('./data/bacteria/otus.nwk')

#read in represent dna sequences
ref_seqs <- readDNAStringSet(file = "./data/bacteria/otus.fa",
                             format = "fasta", nrec = -1L, skip = 0L, seek.first.rec = FALSE, use.names = TRUE)

#import as phyloseq objects
otu.table <- otu_table(otu.table, taxa_are_rows = TRUE)
taxonomy <- tax_table(taxonomy)

#merge into one phyloseq object
bac.phylo <- phyloseq(otu.table, taxonomy, metadata, tree, ref_seqs)
bac.phylo
bac.phylo.rel <- microbiome::transform(bac.phylo, "compositional")

## fungi
#read in otu table
otu.table <- read.delim('./data/fungi/otutab_rare.txt',sep="\t", row.names=1, header = T)
otu.table <- as.matrix(otu.table)

#read in taxonomy, seperated by kingdom phylum class order family genus species 
taxonomy <- read.delim('./data/fungi/taxonomy.txt',sep="\t",row.names=1, header = T)
taxonomy <- as.matrix(taxonomy)

# read in tree
tree <- read_tree('./data/fungi/otus.nwk')

#read in represent dna sequences
ref_seqs <- readDNAStringSet(file = "./data/fungi/otus.fa",
                             format = "fasta", nrec = -1L, skip = 0L, seek.first.rec = FALSE, use.names = TRUE)

#import as phyloseq objects
otu.table <- otu_table(otu.table, taxa_are_rows = TRUE)
taxonomy <- tax_table(taxonomy)

#merge into one phyloseq object
fungi.phylo <- phyloseq(otu.table, taxonomy, metadata, tree, ref_seqs)
fungi.phylo
fungi.phylo.rel <- microbiome::transform(fungi.phylo, "compositional")

## protist
#read in otu table
otu.table <- read.delim('./data/protist/otutab_rare.txt',sep="\t", row.names=1, header = T)
otu.table <- as.matrix(otu.table)

#read in taxonomy, seperated by kingdom phylum class order family genus species 
taxonomy <- read.delim('./data/protist/taxonomy.txt',sep="\t",row.names=1, header = T)
taxonomy <- as.matrix(taxonomy)

# read in tree
tree <- read_tree('./data/protist/otus.nwk')

#read in represent dna sequences
ref_seqs <- readDNAStringSet(file = "./data/protist/otus.fa",
                             format = "fasta", nrec = -1L, skip = 0L, seek.first.rec = FALSE, use.names = TRUE)

#import as phyloseq objects
otu.table <- otu_table(otu.table, taxa_are_rows = TRUE)
taxonomy <- tax_table(taxonomy)

#merge into one phyloseq object
protist.phylo <- phyloseq(otu.table, taxonomy, metadata, tree, ref_seqs)
protist.phylo
protist.phylo.rel <- microbiome::transform(protist.phylo, "compositional")

## animal
#read in otu table
otu.table <- read.delim('./data/animal/otutab_rare.txt',sep="\t", row.names=1, header = T)
otu.table <- as.matrix(otu.table)

#read in taxonomy, seperated by kingdom phylum class order family genus species 
taxonomy <- read.delim('./data/animal/taxonomy.txt',sep="\t",row.names=1, header = T)
taxonomy <- as.matrix(taxonomy)

# read in tree
tree <- read_tree('./data/animal/otus.nwk')

#read in represent dna sequences
ref_seqs <- readDNAStringSet(file = "./data/animal/otus.fa",
                             format = "fasta", nrec = -1L, skip = 0L, seek.first.rec = FALSE, use.names = TRUE)

#import as phyloseq objects
otu.table <- otu_table(otu.table, taxa_are_rows = TRUE)
taxonomy <- tax_table(taxonomy)

#merge into one phyloseq object
animal.phylo <- phyloseq(otu.table, taxonomy, metadata, tree, ref_seqs)
animal.phylo
animal.phylo.rel <- microbiome::transform(animal.phylo, "compositional")
```

# Comunity composition 
```{r}
# phylum.boxplot, Extract list of top N Taxa, taxrank indicate 1 to kingdom, 2(phylum), 3(class)
new.df <-function(phylo.rel, taxrank, k, N) {
     otu_tab <- otu_table((tax_glom(phylo.rel, taxrank)))
     tax.names <- as.vector(tax_table(tax_glom(phylo.rel,taxrank))[,k])
     rownames(otu_tab) <- tax.names
     rowmean <-sapply(1:nrow(otu_tab),function(x) mean(otu_tab[x,]))
     otu_tab<-otu_tab[order(rowmean,decreasing=TRUE), ]
     taxa_list<-rownames(otu_tab)[1:N]
     new_df<-otu_tab[rownames(otu_tab) %in% taxa_list,]
     new_df <- melt(new_df, id.vars = 'taxa')
     colnames(new_df) <- c('taxa','site','relative_abundance')
     new_df$taxa <- factor(new_df$taxa, ordered = T, levels = rev(taxa_list))
     return(new_df)
}

phylum.plot.fun <- function(new_df) {
  p <- ggplot(new_df, aes(x = taxa, y = relative_abundance *100, fill = taxa)) +
    geom_boxplot(outlier.shape = NA) +
    #scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    geom_jitter(color="steelblue", size=1.4, alpha=0.2) +
    theme_classic() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    xlab("")  + ylab('Relative abundance (%)')+
    coord_flip()
  return(p)  
}
new_df_bac <- new.df(bac.phylo.rel, 'Phylum', 2, 10)
new_df_fungi <- new.df(fungi.phylo.rel, 'Phylum', 2, 10)
new_df_protist <- new.df(protist.phylo.rel, 'Phylum', 2, 10)
new_df_animal <- new.df(animal.phylo.rel, 'Class', 3, 10)

bac.phy.boxplot <- phylum.plot.fun(new_df_bac)
fungi.phy.boxplot <- phylum.plot.fun(new_df_fungi)
protist.phy.boxplot <- phylum.plot.fun(new_df_protist)
animal.phy.boxplot <- phylum.plot.fun(new_df_animal)

##determine the class compositions within top 10 phylums##
arrange.tab <- function(phylo, N, taxrank, vect) {
  subphylo <- tax_glom(phylo, taxrank)
  subphylo.rel <- microbiome::transform(subphylo, "compositional")
  ra.tab <- otu_table(subphylo.rel)
  MRA <- rowMeans(ra.tab)
  group <- tax_table(subphylo.rel)[,vect]
  mra.tab <- data.frame(group,MRA)
  colnames(mra.tab) <- c('level1', 'level2', 'MRA')
  #arrange the class table
  library(tidyr)
  mra.tab <- mra.tab %>% spread(level2, MRA)
  mra.tab[is.na(mra.tab)] <- 0
  rownames(mra.tab)<-mra.tab$'level1'
  mra.tab<-as.matrix(t(mra.tab[,-1])*100)
  colsum <-apply(mra.tab,2,sum)
  rowsum<-apply(mra.tab,1,sum)
  top_N_tab<-(mra.tab[order(rowsum,decreasing=TRUE),order(colsum,decreasing=TRUE)])[,1:N]
  head(top_N_tab)
  top_N_tab<-as.matrix(top_N_tab)
  return(top_N_tab)
}

top10phylum_bcateria <- arrange.tab(bac.phylo, 10, 'Class', c(2,3))
top10phylum_bcateria_tab <-data.frame(phylums =colnames(top10phylum_bcateria),
                                      rela_abun = colSums(top10phylum_bcateria))
top10phylum_bcateria_tab

top10phylum_fungi <- arrange.tab(fungi.phylo, 10, 'Class', c(2,3))
top10phylum_fungi_tab <-data.frame(phylums =colnames(top10phylum_fungi),
                                   rela_abun = colSums(top10phylum_fungi))
top10phylum_fungi_tab

top10phylum_protist <- arrange.tab(protist.phylo, 10, 'Class', c(2,3))
top10phylum_protist_tab <-data.frame(phylums =colnames(top10phylum_protist),
                                     rela_abun = colSums(top10phylum_protist))
top10phylum_protist_tab

#soil animal only has 7 classes
top7class_animal <- arrange.tab(animal.phylo, 7, 'Order', c(3,4))
top7class_animal_tab <-data.frame(class =colnames(top7class_animal),
                                  rela_abun = colSums(top7class_animal))
top7class_animal_tab

# Get the stacked barplot
# create color palette:
mycol <-c(119,132,147,454,89,404,123,529,463,104,552,28,54,84,256,100,
          558,43,652,31,610,477,588,99,81,503,562,76,96,495,77,12,90,
          345,255,401,366,276,158,436)

layout(matrix(c(1:8),4,2,byrow = F), c(1,1))
#bacteria
mycol <-colors()[rep(mycol,nrow(top10phylum_bcateria))]
par(mar=c(2,5,2,2))
barplot(top10phylum_bcateria,width=1.8,space=0.4,plot=T,las=2,
        col=mycol[1:nrow(top10phylum_bcateria)],cex.axis=0.8,cex.names=0.7,border=NA,
        xlab = 'Phylum',ylab="Relative abundance(%)",
        offset=0,cex.lab=1)
par(mar=c(2,3.5,3.5,1))
plot.new()
legend("topleft",legend=rownames(top10phylum_bcateria),
       ncol=4,fill=mycol[1:nrow(top10phylum_bcateria)],cex=0.6,bty="n")

#protist
par(mar=c(2,5,2,2))
barplot(top10phylum_protist,width=1.8,space=0.4,plot=T,las=2,
        col=mycol[1:nrow(top10phylum_protist)],cex.axis=0.8,cex.names=0.7,border=NA,
        xlab = 'Phylum',ylab="Relative abundance(%)",
        offset=0,cex.lab=1)
par(mar=c(2,3.5,3.5,1))
plot.new()
legend("topleft",legend=rownames(top10phylum_protist),
       ncol=4,fill=mycol[1:nrow(top10phylum_protist)],cex=0.6,bty="n")

#fungi
par(mar=c(2,5,2,2))
barplot(top10phylum_fungi,width=1.8,space=0.4,plot=T,las=2,
        col=mycol[1:nrow(top10phylum_fungi)],cex.axis=0.8,cex.names=0.7,border=NA,
        xlab = 'Phylum',ylab="Relative abundance(%)",
        offset=0,cex.lab=1)
par(mar=c(2,3.5,3.5,1))
plot.new()
legend("topleft",legend=rownames(top10phylum_fungi),
       ncol=4,fill=mycol[1:nrow(top10phylum_fungi)],cex=0.6,bty="n")

#animal
par(mar=c(2,5,2,2))
barplot(top7class_animal,width=1.8,space=0.4,plot=T,las=2,
        col=mycol[1:nrow(top7class_animal)],cex.axis=0.8,cex.names=0.7,border=NA,
        xlab = 'Phylum',ylab="Relative abundance(%)",
        offset=0,cex.lab=1)
par(mar=c(2,3.5,3.5,1))
plot.new()
legend("topleft",legend=rownames(top7class_animal),
       ncol=4,fill=mycol[1:nrow(top7class_animal)],cex=0.6,bty="n")
par(mfrow=c(1,1))
```
# α diversity
```{r}
alpha_bac <- read.delim('./data/bacteria/result/alpha/vegan.txt',sep="\t", 
                        row.names=1, header = T)
alpha_fungi <- read.delim('./data/fungi/result/alpha/vegan.txt',sep="\t", 
                          row.names=1, header = T)
alpha_protist <- read.delim('./data/protist/result/alpha/vegan.txt',sep="\t", 
                            row.names=1, header = T)
alpha_animal <- read.delim('./data/animal/result/alpha/vegan.txt',sep="\t", 
                           row.names=1, header = T)

alpha_bac <- cbind(tax = rep('Bacteria', 147), alpha_bac[,c(1,4,5)])
alpha_fungi <- cbind(tax = rep('Fungi', 147), alpha_fungi[,c(1,4,5)])
alpha_protist <- cbind(tax = rep('Protist', 147), alpha_protist[,c(1,4,5)])
alpha_animal <- cbind(tax = rep('Animal', 147), alpha_animal[,c(1,4,5)])

diversity <- rbind(alpha_bac, alpha_fungi, alpha_protist, alpha_animal)
melted <- melt(diversity, id.vars = c('tax'))
library(plyr)
ddply(melted, c("tax", "variable"), summarise,
      mean = mean(value), sd = sd(value),
      sem = sd(value)/sqrt(length(value)))
```

# Biogeographic pattern of soil microbiome
## Variation and Distance-Decay relationships
```{r}
deg2rad <- function(deg) return(deg*pi/180)
# Calculates the geodesic distance between two points specified by 
# radian latitude/longitude using the Haversine formula
# Ouputs distance between sites 1 and 2 as meters
gcd.hf <- function(long1, lat1, long2, lat2) {
  R <- 6371 # Earth mean radius [km]
  delta.long <- (long2 - long1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = (R * c)*1000
  return(d) # Distance in meters
}


# Fxn to calculate matrix of distances between each two sites
# INPUT: a data frame in which longs are in first column and lats in second column
# OUTPUT: a distance matrix (class dist) between all pairwise sites
# Output distances are in meters
CalcDists <- function(longlats) {
  name <- list(rownames(longlats), rownames(longlats))
  n <- nrow(longlats)
  z <- matrix(0, n, n, dimnames = name)
  for (i in 1:n) {
    for (j in 1:n) z[i, j] <- gcd.hf(long1 = deg2rad(longlats[i, 1]), 
                                     lat1 = deg2rad(longlats[i, 2]), long2 = deg2rad(longlats[j, 1]), 
                                     lat2 = deg2rad(longlats[j, 2]))
  }
  z <- as.dist(z)
  return(z)
}

library(vegan)
library(ggplot2)
######bacteria#########
# calculate the disimilarity matrix of environment factors based on euclid distance
env.table<-sample_data(bac.phylo)
geo_dist<-data.frame(env.table[,1:2])
geo_dist<-CalcDists(geo_dist)/100000
Geography.dist <- as.numeric(geo_dist)
#determine the euclidean distance of environmental variables
env_vars<-env.table[,-(1:4)]
#standardize the env data
env_vars<-decostand(as.data.frame(env_vars), 'standardize')
env_dist<-vegdist(env_vars, 'euclidean',upper=F)
env.dist<-as.numeric(env_dist)
#DDR
ddr_fun <- function(phylo){
  #otu_tab <- decostand(otu_tab, 'hellinger', MARGIN = 1)
  dist_mat <- vegdist(t(otu_table(phylo)), 'bray', upper=F)
  com_dissimilarty <- as.numeric(dist_mat)*100
  com_similarty <- (1-as.numeric(dist_mat))*100
  dist_tab<-as.data.frame(cbind(com_similarty, com_dissimilarty,
                                Geography.dist, env.dist))
  colnames(dist_tab) <-c ('com_similarty', 'com_dissimilarty',
                          'Geography', 'environment')
  list <- list(dist_tab, dist_mat)
  return(list)
}
bacteria.dis.tab <- ddr_fun(bac.phylo)
fungi.dis.tab <- ddr_fun(fungi.phylo)
protist.dis.tab <- ddr_fun(protist.phylo)
animal.dis.tab <- ddr_fun(animal.phylo)

#ordinary least-squares regressions
bacteria.fit<-lm(com_similarty~Geography,data=bacteria.dis.tab[[1]])
summary(bacteria.fit)
bacteria.ln.fit<-lm(com_similarty/100~log(Geography*100+1),data=bacteria.dis.tab[[1]])
summary(bacteria.ln.fit)

fungi.fit<-lm(com_similarty~Geography,data=fungi.dis.tab[[1]])
summary(fungi.fit)
fungi.ln.fit<-lm(com_similarty/100~log(Geography*100+1),data=fungi.dis.tab[[1]])
summary(fungi.ln.fit)

protist.fit<-lm(com_similarty~Geography,data=protist.dis.tab[[1]])
summary(protist.fit)
protist.ln.fit<-lm(com_similarty/100~log(Geography*100+1),data=protist.dis.tab[[1]])
summary(protist.ln.fit)

animal.fit<-lm(com_similarty~Geography,data=animal.dis.tab[[1]])
summary(animal.fit)
animal.ln.fit<-lm(com_similarty/100~log(Geography*100+1),data=animal.dis.tab[[1]])
summary(animal.ln.fit)

#mantel test
mantel(geo_dist,bacteria.dis.tab[[2]],method="spearman")

mantel(geo_dist,fungi.dis.tab[[2]],method="spearman")

mantel(geo_dist,protist.dis.tab[[2]],method="spearman")

mantel(geo_dist,animal.dis.tab[[2]],method="spearman")

#compare the difference between multi regression slope
library(emmeans)
dat<-rbind(cbind(taxa=c(rep('Bacteria',nrow(bacteria.dis.tab[[1]]))),bacteria.dis.tab[[1]]),
           cbind(taxa=c(rep('Fungi',nrow(fungi.dis.tab[[1]]))),fungi.dis.tab[[1]]),
           cbind(taxa=c(rep('Protists',nrow(protist.dis.tab[[1]]))),protist.dis.tab[[1]]),
           cbind(taxa=c(rep('Animal',nrow(animal.dis.tab[[1]]))),animal.dis.tab[[1]]))

##comparison of slope of DDRs
m.interaction <- lm(com_similarty ~ Geography*taxa, data = dat)
anova(m.interaction)

# Obtain slopes
m.interaction$coefficients
geo.lst <- emtrends(m.interaction, "taxa", var="Geography")

# Compare slopes
pairs(geo.lst)

#compare the variations of composition
library(plyr)
ddply(dat, c("taxa"), summarise,
      mean = mean(com_dissimilarty/100), sd = sd(com_dissimilarty/100),
      se = sd(com_dissimilarty/100)/sqrt(length(com_dissimilarty)))

mode_ln<-aov(com_dissimilarty/100~taxa,dat)
summary(mode_ln)
TukeyHSD(mode_ln)$taxa

##plot
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 4
cols = gg_color_hue(n)
dat$taxa<-factor(dat$taxa,ordered=T,levels = c('Bacteria','Fungi', 'Protists','Animal'))

p_dissimilarty<-ggplot(dat,aes(taxa,com_dissimilarty/100))+
  geom_violin(trim=T,aes(fill=taxa))+
  scale_fill_manual(values= cols)+
  geom_boxplot(width=0.1,fill="white")+
  xlab('Taxa')+ylab('Community dissimilarity')+
  theme(axis.title = element_text(size=9),axis.text = element_text(size=7),
        panel.grid = element_blank(),legend.position='none')

p_distance<-ggplot(dat,aes(Geography,com_similarty)) + 
  geom_point(shape=19,alpha=0.1,aes(colour = taxa))+
  scale_color_manual(values=cols)+
  geom_smooth(method="lm", size=1, se=T,colour='black') +
  facet_wrap( .~ taxa , scales="free",ncol = 2) +
  ylab('Community similarity')+xlab('Geographic distance(100km)')+
  theme(axis.title = element_text(size=9),axis.text = element_text(size=7),
        strip.text = element_text(size = 9),legend.position='none',panel.grid = element_blank())

p_ln.distance<-ggplot(dat,aes(log(Geography*100+1),com_similarty/100)) + 
  geom_point(shape=19,alpha=0.1,aes(colour = taxa))+
  scale_color_manual(values=cols)+
  geom_smooth(method="lm", size=1, se=T,colour='black') +
  facet_wrap( .~ taxa , scales="free",ncol = 2) +
  ylab('Community similarity')+xlab('Ln(Geographic distance(km)+1)')+
  theme(axis.title = element_text(size=9),axis.text = element_text(size=7),
        strip.text = element_text(size = 9),legend.position='none',panel.grid = element_blank())

library(cowplot)
combine1<-plot_grid(p_dissimilarty,p_distance,
                    labels = c('(a)','(b)'), ncol = 2, label_x = .03,label_y = 1,
                    rel_widths = c(2, 3),hjust = 0, label_size=8)
combine1
```

## Test sampling effort
```{r}
library(vegan)
library(ggplot2)
## calculate the disimilarity matrix of environment factors based on euclid distance
env.table<-sample_data(bac.phylo)
geo_dist<-data.frame(env.table[,1:2])
geo_dist<-CalcDists(geo_dist)/100000
Geography.dist <- as.numeric(geo_dist)

# This function was modified according Meyer et al. 2018 ISME-J, DOI: 10.1038/s41396-018-0103-3, 
# which performs a single rarefaction of a community matrix, calculates the slope 
# of the distance-decay relationship of that community, then repeats iteratively. It was
# designed to explore the relationship between sampling effort and biogeographic patterns.

# The user provides: 
# 'otu' - a community matrix with samples as rows and columns as taxa, 
# 'depth'- the level to which the community should be rarefied,  
# 'geo'- a matrix of geographic distance between samples (with sample names that match 'otu'),
# 'method'- the desired community dissimilarity metric (see Vegan package, function 'vegdist' for metric options),
# 'niter' -  the number of iterations that a community matrix will be rarefied then regressed against distance.

sampling_effort_dd <- function(otu, depth, geo, method, niter){
  require(vegan)
  require(labdsv)
  slope_df <- data.frame('Slope_est'=as.numeric(), 'Std_er'=as.numeric(), 't_val'=as.numeric(), 'p'=as.numeric())
  for(i in 1:niter){
    otu_rare <-suppressWarnings(rrarefy(otu, sample=depth))
    otu_rare <- otu_rare[which(rowSums(otu_rare) >= (0.95 *depth)),] 
    geo <- geo[which(row.names(geo) %in% row.names(otu_rare)),
               which(row.names(geo) %in% row.names(otu_rare))]
    
    bray <- as.matrix(vegdist(otu_rare, method=method))
    bray[upper.tri(bray)] <- 0 
    bray_long <- dematrify(as.data.frame(bray))
    bray_long$Bray <- bray_long$abundance
    bray_long$abundance <- NULL
    bray_long$Geodist <- NA
    
    geo[upper.tri(geo)] <- 0 
    geo_long <- dematrify(as.data.frame(geo))
    dist_combined <- bray_long
    dist_combined$Geodist <- geo_long$abundance
    dist_combined$Bray <- (1- dist_combined$Bray)*100
    dist_combined$Geodist <- dist_combined$Geodist
    lmcoef <- data.frame(summary(lm(dist_combined$Bray ~ dist_combined$Geodist))$coefficient)
    slope_df[i,] <- lmcoef[2,]
  }
  return(slope_df)
}

## calculate the geographic distance based on euclid distance
env.table<-sample_data(bac.phylo)
geo_dist<-data.frame(env.table[,1:2])
geo_dist<-as.matrix(CalcDists(geo_dist)/100000)

#calculates the slope of the distance-decay relationship with 100 iterations at defferent rarefication levels.
#bacteria
otu.table <- read.delim('./data/bacteria/otutab.txt',sep="\t", row.names=1, header = T)
bac.otu.table <- as.matrix(t(otu.table))
slop_bac_rare10000 <- sampling_effort_dd(bac.otu.table, 10000, geo_dist, "bray", 100)
slop_bac_rare7000 <- sampling_effort_dd(bac.otu.table, 7000, geo_dist, "bray", 100)
slop_bac_rare3500 <- sampling_effort_dd(bac.otu.table, 3500, geo_dist, "bray", 100)

#fungi
otu.table <- read.delim('./data/fungi/otutab.txt',sep="\t", row.names=1, header = T)
fungi.otu.table <- as.matrix(t(otu.table))
slop_fungi_rare2000 <- sampling_effort_dd(fungi.otu.table, 2000, geo_dist, "bray", 100)
slop_fungi_rare1500 <- sampling_effort_dd(fungi.otu.table, 1500, geo_dist, "bray", 100)
slop_fungi_rare800 <- sampling_effort_dd(fungi.otu.table, 800, geo_dist, "bray", 100)

#protist
otu.table <- read.delim('./data/protist/otutab.txt',sep="\t", row.names=1, header = T)
protist.otu.table <- as.matrix(t(otu.table))
slop_protist_rare550 <- sampling_effort_dd(protist.otu.table, 550, geo_dist, "bray", 100)
slop_protist_rare400 <- sampling_effort_dd(protist.otu.table, 400, geo_dist, "bray", 100)
slop_protist_rare250 <- sampling_effort_dd(protist.otu.table, 250, geo_dist, "bray", 100)

#animal
otu.table <- read.delim('./data/animal/otutab.txt',sep="\t", row.names=1, header = T)
animal.otu.table <- as.matrix(t(otu.table))
slop_animal_rare280 <- sampling_effort_dd(animal.otu.table, 280, geo_dist, "bray", 100)
slop_animal_rare150 <- sampling_effort_dd(animal.otu.table, 150, geo_dist, "bray", 100)
slop_animal_rare100 <- sampling_effort_dd(animal.otu.table, 100, geo_dist, "bray", 100)

#melt the data
bac.slop <- data.frame(tax = rep('Bacteria', 300), 
                       depth = factor(c(rep(10000, 100), rep(7000, 100), rep(3500, 100))),
                       Slope_est = c(slop_bac_rare10000$Slope_est, slop_bac_rare7000$Slope_est,
                                     slop_bac_rare3500$Slope_est))
mode <- aov(Slope_est~depth, data = bac.slop)
TukeyHSD(mode)
fungi.slop <- data.frame(tax = rep('Fungi', 300), 
                         depth = factor(c(rep(2000, 100), rep(1500, 100), rep(800, 100))),
                         Slope_est = c(slop_fungi_rare2000$Slope_est, slop_fungi_rare1500$Slope_est,
                                       slop_fungi_rare800$Slope_est))
mode <- aov(Slope_est~depth, data = fungi.slop)
TukeyHSD(mode)
protist.slop <- data.frame(tax = rep('Protist', 300), 
                           depth = factor(c(rep(550, 100), rep(400, 100), rep(250, 100))),
                           Slope_est = c(slop_protist_rare550$Slope_est, slop_protist_rare400$Slope_est,
                                         slop_protist_rare250$Slope_est))
mode <- aov(Slope_est~depth, data = protist.slop)
TukeyHSD(mode)
animal.slop <- data.frame(tax = rep('Animal', 300), 
                          depth = factor(c(rep(280, 100), rep(150, 100), rep(100, 100))),
                          Slope_est = c(slop_animal_rare280$Slope_est, slop_animal_rare150$Slope_est,
                                        slop_animal_rare100$Slope_est))
mode <- aov(Slope_est~depth, data = animal.slop)
TukeyHSD(mode)
slop_df <- data.frame(rbind(bac.slop, fungi.slop, protist.slop, animal.slop))
slop_df$depth <- as.character(slop_df$depth)
slop_df$depth <- factor(slop_df$depth, ordered = T,
                        levels = c('10000', '7000', '3500',
                                   '2000', '1500', '800',
                                   '550', '400', '250',
                                   '280', '150', '100'))
slop_df$tax <- factor(slop_df$tax, ordered = T, 
                      levels = c('Bacteria', 'Fungi', 'Protist', 'Animal'))
#boxplot
library(ggplot2)
g_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 4
cols = gg_color_hue(n)
mytheme<-theme_bw()+
  theme(axis.title = element_text(size = 9),
        axis.text = element_text(size=7, colour = 'black'),
        panel.grid = element_blank(),
        #strip.background = element_rect(fill = 'skyblue'),
        strip.text = element_text(size = 9))

p_rare_slope<-ggplot(slop_df,aes(x=depth,y=Slope_est))+
  geom_boxplot(width=0.3,aes(fill=tax))+
  scale_fill_manual(values=cols)+
  ylab('DD Slope')+ xlab('Rarefication level') +
  #scale_x_discrete(limits=c('Bacteria','Fungi','Protist','Animal'))+
  #facet_wrap(variable~., scales="free",ncol = 3)+
  mytheme
p_rare_slope
```

# Multivariables analysis
## variation partitioning with two-way PERMANOVA
Regression approach with distance as response and raw predictors
reference:https://media.nature.com/original/nature-assets/ismej/journal/v12/n2/extref/ismej2017183x2.txt
```{r}
DistResponseReg <-function (DistMatrix,X) {
  DistMatrix <- as.matrix(DistMatrix)
  X <- as.matrix(X)
  n <- nrow(DistMatrix)
  p <- ncol(X)
  row.wt = rep(1, nrow(DistMatrix))
  col.wt = rep(1, ncol(DistMatrix))
  st <- sum(col.wt)
  sr <- sum(row.wt)
  row.wt <- row.wt/sr
  col.wt <- col.wt/st
  DistMatrix <- -0.5*(DistMatrix*DistMatrix)
  row.mean <- apply(row.wt * DistMatrix, 2, sum)
  col.mean <- apply(col.wt *t(DistMatrix), 2, sum)
  col.mean <- col.mean - sum(row.mean * col.wt)
  DistMatrix <- sweep(DistMatrix, 2, row.mean)
  G <- t(sweep(t(DistMatrix), 2, col.mean))
  H<-X%*%solve(t(X)%*%X)%*%t(X)
  I<-diag(n)
  predicted <- H%*%G%*%H
  residuals <- (I-H)%*%G%*%(I-H)
  MS_regression<-sum(diag(predicted))/p
  MS_residual<-sum(diag(residuals))/(n-p)
  F<-MS_regression/MS_residual
  MS_Total=sum(diag(G))/n;
  RsqAdj=1-MS_residual/MS_Total;
  
  result <- list(Rsq_Adj=RsqAdj,F_value=F,res_matrix=residuals,pred_matrix=predicted)
  return(result)
  
}

# variation partitioning with distance matrix as response
# and X (e.g., environment) and W (e.g., space or connectivity)
VarPartDistResponse<-function (Dist_Matrix,X,W,Number_Permutations) {
  X <- as.matrix(X)
  X <- apply(X, 2, scale)
  W <- as.matrix(W)
  W <- apply(W, 2, scale)
  Dist_Matrix <- as.matrix(Dist_Matrix)
  Number_Predictors_X <- ncol(X)
  Number_Predictors_W <- ncol(W)
  n<-nrow(X)
  
  XW <- as.matrix(cbind(X,W));
  result <- DistResponseReg(Dist_Matrix,XW)
  abc <- result$Rsq_Adj
  Fabc <- result$F_value
  
  result <- DistResponseReg(Dist_Matrix,X)
  ab <- result$Rsq_Adj
  Fab <- result$F_value
  residuals_X <- result$res_matrix 
  predicted_X <- result$pred_matrix
  
  result <- DistResponseReg(Dist_Matrix,W)
  bc <- result$Rsq_Adj
  Fbc <- result$F_value
  residuals_W <- result$res_matrix 
  predicted_W <- result$pred_matrix
  
  # unique fraction of contribution related to X
  a <- abc - bc
  # unique fraction of contribution related to W
  c <- abc- ab
  # common fraction of contribution between X and W
  b <- abc - a - c
  # residual fraction
  d <- 1-abc
  
  Fa=(a/Number_Predictors_X)/(d/(n-Number_Predictors_X-Number_Predictors_W));
  Fc=(c/Number_Predictors_W)/(d/(n-Number_Predictors_X-Number_Predictors_W));
  
  Prob_abc=1/Number_Permutations; Prob_ab=1/Number_Permutations; Prob_bc=1/Number_Permutations; Prob_a=1/Number_Permutations; Prob_c=1/Number_Permutations;
  
  # permutations test
  for (i in 1:(Number_Permutations-1)) {
    # testing fraction a; notice that we permute the residual values in W and not in X
    permuted_rows=sample(n,replace=FALSE)
    # permuting the residual matrix, which is from the distance, and hence the need to permute
    # rows and columns in the same way, hence the use of permuted_rows for columns and rows below
    # testing fraction a
    # Yperm=predicted_W+residuals_W[permuted_rows,permuted_rows] # implement permutation of residuals in the future
    
    # testing fraction a
    result <- DistResponseReg(Dist_Matrix,XW[permuted_rows,])
    abcRnd <- result$Rsq_Adj
    FabcRnd <- result$F_value
    result <- DistResponseReg(Dist_Matrix,W[permuted_rows,])
    bcRnd <- result$Rsq_Adj
    FbcRnd <- result$F_value
    aRnd=abcRnd-bcRnd;
    dRnd=1-abcRnd;
    FaRnd=(aRnd/Number_Predictors_X)/(dRnd/(n-Number_Predictors_X-Number_Predictors_W));
    if (FaRnd >= Fa) {Prob_a<-Prob_a+1/Number_Permutations}
    
    # testing fraction c
    result <- DistResponseReg(Dist_Matrix,X[permuted_rows,])
    abRnd <- result$Rsq_Adj
    FabRnd <- result$F_value
    cRnd=abcRnd-abRnd;
    FcRnd=(cRnd/Number_Predictors_W)/(dRnd/(n-Number_Predictors_X-Number_Predictors_W));
    if (FcRnd >= Fc) {Prob_c<-Prob_c+1/Number_Permutations}
    
    # testing abc
    if (FabcRnd >= Fabc) {Prob_abc<-Prob_abc+1/Number_Permutations}
    # testing ab
    if (FabRnd >= Fab) {Prob_ab<-Prob_ab+1/Number_Permutations}
    # testing bc
    if (FbcRnd >= Fbc) {Prob_bc<-Prob_bc+1/Number_Permutations}
    
  }
  
  result <- mat.or.vec(7,2)
  
  result[1,1] <- abc
  result[2,1] <- ab
  result[3,1] <- bc
  result[4,1] <- a
  result[5,1] <- c
  result[6,1] <- b
  result[7,1] <- d
  
  result[1,2] <- Prob_abc
  result[2,2] <- Prob_ab
  result[3,2] <- Prob_bc
  result[4,2] <- Prob_a
  result[5,2] <- Prob_c
  result[6,2] <- NA
  result[7,2] <- NA
  
  colnames(result) <- c("Estimate","p-value")
  rownames(result) <- c("abc","ab","bc","a","c","b","d")
  result<-as.data.frame(result)
  return(result)
}

# model selection for linear model with distance as response
#reference:
SelectionDistResponseReg<-function (Dist_Matrix,X,Number_Permutations,alpha) {
  X <- as.matrix(X)
  Number_Predictors<-ncol(X)
  n<-nrow(X)
  Dist_Matrix <- as.matrix(Dist_Matrix)
  X <- apply(X, 2, scale)
  result<-DistResponseReg(Dist_Matrix,X);
  F_Observed<-result$F_value
  # global test with all predictors
  Prob_Global<-1/Number_Permutations
  for (i in 1:(Number_Permutations-1)) {
    X_permuted<-X[sample(n,replace=FALSE),]
    result<-DistResponseReg(Dist_Matrix,X_permuted)
    F_Random<-result$F_value
    if (F_Random >= F_Observed) {Prob_Global<-Prob_Global+1/Number_Permutations}
  }
  
  # set of these as NA in the global model is not significant
  Variables_In_Model <- NA
  Rsq_Final_Model <- NA
  if (Prob_Global < alpha) {
    # calculate contribution of each predictor separately as they're orthgonal
    F_Ind_X<-mat.or.vec(Number_Predictors,1)
    for (i in 1:Number_Predictors) {
      F_Ind_X[i]<-DistResponseReg(Dist_Matrix,X[,i])[2]
    }
    # start selection
    Variables_In_Model<-as.matrix(which.max(F_Ind_X))
    F_Ind_X[Variables_In_Model[1]]<-NA
    #Original_Columns=as.matrix(1:n)
    #Original_Columns[Variable_In_Model]<-NA
    found <- FALSE
    while (found == FALSE) { 
      # this could be made faster by not calculating again the F for the first variable entered, but this version is more general
      # contrast current model with the largest variable contribution not entered in the model
      candidate_model <- cbind(X[,Variables_In_Model],X[,which.max(F_Ind_X)])
      result_candidate <- DistResponseReg(Dist_Matrix,candidate_model)
      F_candidate_Obs <- result_candidate[2]
      # test wheter the entered variable improves fit
      Prob_F <- 1/Number_Permutations
      for (i in 1:(Number_Permutations-1)) {
        candidate_predictor <- which.max(F_Ind_X)
        candidate_model <- cbind(X[,Variables_In_Model],X[sample(n,replace=FALSE),candidate_predictor])
        result_candidate <- DistResponseReg(Dist_Matrix,candidate_model);
        F_candidate_Rnd <- result_candidate$F_value
        if (F_candidate_Rnd >= F_candidate_Obs) {Prob_F<-Prob_F+1/Number_Permutations}
      }
      if (Prob_F > alpha) {found <- TRUE} else {
        F_Ind_X[candidate_predictor] <- NA
        Variables_In_Model <- append(Variables_In_Model,candidate_predictor)
      }
      
      # nrow(na.omit(OriginalColumns))
    }
    result<-DistResponseReg(Dist_Matrix,X[,Variables_In_Model])
    Rsq_Final_Model<-result$Rsq_Adj
  }
  
  result <- list(Global_P=Prob_Global,Rsq_Selected_Model=Rsq_Final_Model,Selected_Variables=Variables_In_Model)
  return(result)
}

#Construct a variation partition function 
vp <- function(phylo){
  set.seed(999)
  require(vegan)
  siteXspe <- t(otu_table(phylo))
  siteXspe <- as.matrix(siteXspe)
  env <- sample_data(phylo)
  env_vars<-env[,-c(1:4)]
  Geography_vars<-env[,c(1:2)]
  otu_tab <- decostand(siteXspe, 'hellinger')
  commu.dist<-vegdist(otu_tab, 'bray',upper=F)
  pcnm_vars <- (pcnm(dist(Geography_vars)))$vectors
  # check collinearities among all variables
  env_df <- as.matrix(env_vars)
  env_df <- decostand(env_df,"standardize")
  pcnm_df <- as.matrix(pcnm_vars)
  all.vars <- data.frame(env_df, pcnm_df)
  ord <- dbrda(otu_tab~., all.vars)
  ord.vif <- vif.cca(ord)
  #remove the varibles with vif >20
  all.vars <- all.vars[,names(ord.vif[ord.vif < 20])]
  env_mat <- env_df[,c(intersect(colnames(env_df),colnames(all.vars)))]
  pcnm_mat <- pcnm_df[,c(intersect(colnames(pcnm_df),colnames(all.vars)))]
  #variables selection
  env_sel_vars<-env_mat[,SelectionDistResponseReg(commu.dist, env_mat,999,0.05)$Selected_Variables]
  pcnm_sel_vars<-pcnm_mat[,SelectionDistResponseReg(commu.dist, pcnm_mat,999,0.05)$Selected_Variables]
  #conduct VPA
  vp<-VarPartDistResponse(commu.dist,env_sel_vars,pcnm_sel_vars,999)
  results<-list(vp,env_sel_vars,pcnm_sel_vars)
  return(results)
}

vp.bacteria<-vp(bac.phylo)
vp.fungi<-vp(fungi.phylo)
vp.protists<-vp(protist.phylo)
vp.animal<-vp(animal.phylo)

bacteria_vp<-vp.bacteria[[1]]
bacteria_env_df<-vp.bacteria[[2]]
bacteria_geo_df<-vp.bacteria[[3]]
colnames(bacteria_env_df)
colnames(bacteria_geo_df)

fungi_vp<-vp.fungi[[1]]
fungi_env_df<-vp.fungi[[2]]
fungi_geo_df<-vp.fungi[[3]]
colnames(fungi_env_df)
colnames(fungi_geo_df)

protists_vp<-vp.protists[[1]]
protists_env_df<-vp.protists[[2]]
protists_geo_df<-vp.protists[[3]]
colnames(protists_env_df)
colnames(protists_geo_df)

animal_vp<-vp.animal[[1]]
animal_env_df<-vp.animal[[2]]
animal_geo_df<-vp.animal[[3]]
colnames(animal_env_df)
colnames(animal_geo_df)

#plot
#first, variable partition plot
theme_set(theme_grey())
library(reshape)
library(ggplot2)
Sorting_effect=c(bacteria_vp[4,1],fungi_vp[4,1],protists_vp[4,1],animal_vp[4,1])*100
dispersal_effect=c(bacteria_vp[5,1],fungi_vp[5,1],protists_vp[5,1],animal_vp[5,1])*100
sorting.dispersal=c(bacteria_vp[6,1],fungi_vp[6,1],protists_vp[6,1],animal_vp[6,1])*100
sort.dispersal.ration=c(Sorting_effect/dispersal_effect)
vp.dat<-data.frame(taxa=c('Bacteria','Fungi','Protists','Animal'),Sorting_effect,
                   dispersal_effect,sorting.dispersal,sort.dispersal.ration)
vp.dat$taxa<-factor(vp.dat$taxa,ordered = T,
                    levels=c('Bacteria','Fungi','Protists','Animal'))

melted <- melt(vp.dat, id.vars=c("taxa"))
vp.dat <- melted[1:12, ]
sdr.dat <- melted[13:16, ]

# Stacked plot for vpa
#set color
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 4
cols = gg_color_hue(4)
vp.plot<-ggplot(vp.dat, aes(fill= variable, y=value, x=taxa)) +
  geom_bar(position="stack", stat="identity", width = 0.75)+
  #scale_fill_manual(values=cols)+
  xlab('Taxa')+ylab('Explained variation (%)')+
  scale_x_discrete(limits=c('Bacteria','Fungi','Protists','Animal'))+
  theme(axis.title = element_text(size=9),
        axis.text = element_text(size=7, colour = 'black'),
        strip.text = element_text(size = 9),legend.position=c(0.70, 0.85),
        panel.grid = element_blank())

#barplot for Sorting/dispersal effect ratio
sdr.plot<-ggplot(sdr.dat,aes(x=taxa, y=value)) +
  geom_bar(stat = 'identity',aes(fill='a1caf1'), width = 0.75)+
  scale_fill_manual(values=cols)+
  xlab('Taxa')+ylab('Sorting/dispersal effect ratio')+
  scale_x_discrete(limits=c('Bacteria','Fungi','Protists','Animal'))+
  theme(axis.title = element_text(size=9),
        axis.text = element_text(size=7, colour = 'black'),
        strip.text = element_text(size = 9),legend.position ='none',
        panel.grid = element_blank())
library(cowplot)
plot_grid(vp.plot, sdr.plot,
          labels = c("(a)", "(b)"), ncol = 2, nrow = 1, label_x = .01,
          label_y = 1.005,hjust = 0, label_size=8,align = "v")
```

# distance-based redundancy analysis (dbRDA) and plot with color gradient for AI
```{r}
beta_dbrda <- function(phylo, env_df, geo_df) {
  p_list=c("ggplot2", "vegan", "ggrepel")
  for(p in p_list){
    if (!requireNamespace(p)){
      install.packages(p)}
    suppressWarnings(suppressMessages(library(p,character.only=T)))}
  otu_tab <- as.matrix(t(otu_table(phylo)))
  otu_tab <- decostand(otu_tab, 'hellinger')
  env_df <- as.matrix(env_df)
  env <- decostand(env_df,"standardize")
  geo <- as.matrix(geo_df)
  all.vars <- data.frame(env, geo)
  ord <- dbrda(otu_tab ~., all.vars)
  mode <- anova(ord, by = 'margin')
  eig <- ord$CCA$eig
  vare_spp_sco <- scores(ord, display = "species")
  vare_sam_sco <- scores(ord, display = "sites")
  vare_env_sco <- scores(ord, display = "bp")
  vare_env_sco <- vare_env_sco[which(mode$`Pr(>F)` < 0.05),]
  points <- data.frame(vare_sam_sco,data.frame(sample_data(phylo))$AI)
  colnames(points)=c("x", "y", 'AI')
  fit_coord_cont <- data.frame(vare_env_sco, variables = rownames(vare_env_sco))
  ggplot(data = points, aes(x = x, y = y)) + 
    geom_point(data = points, aes(colour = AI), size = 1, alpha = 0.8) + 
    scale_colour_gradientn(colours = terrain.colors(10))+
    geom_segment(data = fit_coord_cont,
                 aes(x = 0, xend = dbRDA1*1.8, y = 0, yend = dbRDA2*1.8),
                 arrow = arrow(length = unit(0.25, "cm")), colour = "grey", lwd = 0.5) +
    geom_text(data = fit_coord_cont, aes(x = dbRDA1*1.8, y = dbRDA2*1.8, label = variables), colour = "black", 
              size = 1) +
    labs(x=paste("dbRDA1 (", format(100 * eig[1] / sum(eig), digits=4), "%)", sep=""),
         y=paste("dbRDA2 (", format(100 * eig[2] / sum(eig), digits=4), "%)", sep="")) +
    theme(axis.title = element_text(size = 9, colour = "black"),
          axis.text = element_text(size = 7, colour = "black"),
          legend.title = element_text(size = 8),
          legend.text = element_text(size = 7),
          panel.grid = element_blank(),
          panel.background = element_blank(), 
          panel.border = element_rect(fill = NA, colour = "black"))
}

p1 <- beta_dbrda(bac.phylo, bacteria_env_df, bacteria_geo_df)
p2 <- beta_dbrda(fungi.phylo, fungi_env_df, fungi_geo_df)
p3 <- beta_dbrda(protist.phylo, protists_env_df, protists_geo_df)
p4 <- beta_dbrda(animal.phylo, animal_env_df, animal_geo_df)

library(cowplot)
plot_grid(p1, p2, p3, p4,
          labels = c("(a)", "(b)", "(c)", "(d)"), ncol = 2, nrow = 2, label_x = .01,
          label_y = 1.005,hjust = 0, label_size=8,align = "v")
```


# NULL model analysis
```{r}
#function for extract the most 1000 abundant ASVs
filter.abun <- function(phylo, N) {
  require(phyloseq)
  comun <- otu_table(phylo)
  rowmean <-sapply(1:nrow(comun),function(x) mean(comun[x,]))
  comun <- comun[order(rowmean,decreasing=TRUE), ]
  taxa_list <- rownames(comun)[1:N]
  otu_tab <- comun[rownames(comun) %in% taxa_list,]
  otu_tab <- data.frame(t(otu_tab))
  return(otu_tab)
}

filter.tree <- function(phylo, otu_tab) {
  require(phyloseq)
  require(ape)
  tree <- phy_tree(phylo)
  tips<-colnames(otu_tab)
  tree<-keep.tip(tree,tips)
}

#extract the most 1000 abundant ASVs
#bacteria
filter.bac.tab <- filter.abun(bac.phylo, 1000)
ncol(filter.bac.tab)
sum(filter.bac.tab)/sum(otu_table(bac.phylo))
bacteria.tree <- filter.tree(bac.phylo, filter.bac.tab)
#fungi
filter.fungi.tab <- filter.abun(fungi.phylo, 1000)
ncol(filter.fungi.tab)
sum(filter.fungi.tab)/sum(otu_table(fungi.phylo))
fungi.tree <- filter.tree(fungi.phylo, filter.fungi.tab)
#protist
filter.protist.tab <- filter.abun(protist.phylo, 1000)
ncol(filter.protist.tab)
sum(filter.protist.tab)/sum(otu_table(protist.phylo))
protist.tree <- filter.tree(protist.phylo, filter.protist.tab)
#animal
filter.animal.tab <- filter.abun(animal.phylo, nrow(otu_table(animal.phylo)))
ncol(filter.animal.tab)
sum(filter.animal.tab)/sum(otu_table(animal.phylo))
animal.tree <- filter.tree(animal.phylo, filter.animal.tab)
```

R codes for null model analysis modified according to Stegen et al. (2013) ####
```{r}
#phylo: Phylogenetic tree of each OTU
#comun: A community table with samples as rows and OTUs as columns. 
#Beta_NTI
Beta_NTI<-function(tree,comun){
  require(picante)
  ## make sure the names on the phylogeny are ordered the same as the names in otu table
  match.phylo.comun = match.phylo.data(tree, t(comun));
  ## calculate empirical betaMNTD
  beta.mntd.weighted = as.matrix(comdistnt(t(match.phylo.comun$data),cophenetic(match.phylo.comun$phy),abundance.weighted=T));
  identical(colnames(match.phylo.comun$data),colnames(beta.mntd.weighted)); # just a check, should be TRUE
  identical(colnames(match.phylo.comun$data),rownames(beta.mntd.weighted)); # just a check, should be TRUE
  # calculate randomized betaMNTD
  beta.reps = 9; # number of randomizations
  rand.weighted.bMNTD.comp = array(c(-9),dim=c(ncol(match.phylo.comun$data),ncol(match.phylo.comun$data),beta.reps));
  for (rep in 1:beta.reps) {
    rand.weighted.bMNTD.comp[,,rep] = as.matrix(comdistnt(t(match.phylo.comun$data),
                                                          taxaShuffle(cophenetic(match.phylo.comun$phy)),
                                                          abundance.weighted = T,exclude.conspecifics = F));
    print(c(date(),rep));
  }
  weighted.bNTI = matrix(c(NA),nrow=ncol(match.phylo.comun$data),ncol=ncol(match.phylo.comun$data));
  dim(weighted.bNTI);
  for (columns in 1:(ncol(match.phylo.comun$data)-1)) {
    for (rows in (columns+1):ncol(match.phylo.comun$data)) {
      
      rand.vals = rand.weighted.bMNTD.comp[rows,columns,];
      weighted.bNTI[rows,columns] = (beta.mntd.weighted[rows,columns] - mean(rand.vals)) / sd(rand.vals);
      rm("rand.vals");
    };
  };
  rownames(weighted.bNTI) = colnames(match.phylo.comun$data);
  colnames(weighted.bNTI) = colnames(match.phylo.comun$data);
  results<-as.dist(weighted.bNTI);
  return(results)
}

#RC_bray
raup_crick= function(comun, reps=9){
  require(ecodist) 
  ## count number of sites and total species richness across all plots (gamma)
  n_sites<-nrow(comun)
  gamma<-ncol(comun)
  ##build a site by site matrix for the results, with the names of the sites in the row and col names:
  results<-matrix(data=NA, nrow=n_sites, ncol=n_sites, dimnames=list(row.names(comun), row.names(comun)))
  ##make the comun matrix into a new, pres/abs. matrix:
  ceiling(comun/max(comun))->comun.inc
  ##create an occurrence vector- used to give more weight to widely distributed species in the null model:
  occur<-apply(comun.inc, MARGIN=2, FUN=sum)
  ##create an abundance vector- used to give more weight to abundant species in the second step of the null model:
  abundance<-apply(comun, MARGIN=2, FUN=sum)
  ##make_null:
  ##looping over each pairwise community combination:
  for(null.one in 1:(nrow(comun)-1)){
    for(null.two in (null.one+1):nrow(comun)){
      null_bray_curtis<-NULL
      for(i in 1:reps){
        ##two empty null communities of size gamma:
        com1<-rep(0,gamma)
        com2<-rep(0,gamma)
        ##add observed number of species to com1, weighting by species occurrence frequencies:
        com1[sample(1:gamma, sum(comun.inc[null.one,]), replace=FALSE, prob=occur)]<-1
        com1.samp.sp = sample(which(com1>0),(sum(comun[null.one,])-sum(com1)),replace=TRUE,prob=abundance[which(com1>0)]);
        com1.samp.sp = cbind(com1.samp.sp,1); # head(com1.samp.sp);
        com1.sp.counts = as.data.frame(tapply(com1.samp.sp[,2],com1.samp.sp[,1],FUN=sum)); colnames(com1.sp.counts) = 'counts'; # head(com1.sp.counts);
        com1.sp.counts$sp = as.numeric(rownames(com1.sp.counts)); # head(com1.sp.counts);
        com1[com1.sp.counts$sp] = com1[com1.sp.counts$sp] + com1.sp.counts$counts; # com1;
        #sum(com1) - sum(spXsite[null.one,]); ## this should be zero if everything work properly
        rm('com1.samp.sp','com1.sp.counts');			
        ##same for com2:
        com2[sample(1:gamma, sum(comun.inc[null.two,]), replace=FALSE, prob=occur)]<-1
        com2.samp.sp = sample(which(com2>0),(sum(comun[null.two,])-sum(com2)),replace=TRUE,prob=abundance[which(com2>0)]);
        com2.samp.sp = cbind(com2.samp.sp,1); # head(com2.samp.sp);
        com2.sp.counts = as.data.frame(tapply(com2.samp.sp[,2],com2.samp.sp[,1],FUN=sum)); colnames(com2.sp.counts) = 'counts'; # head(com2.sp.counts);
        com2.sp.counts$sp = as.numeric(rownames(com2.sp.counts)); # head(com2.sp.counts);
        com2[com2.sp.counts$sp] = com2[com2.sp.counts$sp] + com2.sp.counts$counts; # com2;
        # sum(com2) - sum(spXsite[null.two,]); ## this should be zero if everything work properly
        rm('com2.samp.sp','com2.sp.counts');
        null.comun = rbind(com1,com2); # null.comun;
        ##calculate null bray curtis
        null_bray_curtis[i] = distance(null.comun,method='bray-curtis');
      }; # end reps loop
      ## empirically observed bray curtis
      obs.bray = distance(comun[c(null.one,null.two),],method='bray-curtis');
      ##how many null observations is the observed value tied with?
      num_exact_matching_in_null = sum(null_bray_curtis==obs.bray);
      ##how many null values are smaller than the observed *dissimilarity*?
      num_less_than_in_null = sum(null_bray_curtis<obs.bray);
      rc = ((num_less_than_in_null +(num_exact_matching_in_null)/2)/reps)
      ##modification of raup crick standardizes the metric to range from -1 to 1 instead of 0 to 1
      rc = (rc-.5)*2
      results[null.two,null.one] = round(rc,digits=2); ##store the metric in the results matrix
      print(c(null.one,null.two,date()));
    }; ## end null.two loop
  }; ## end null.one loop
  
  results<-as.dist(results)
  return(results)
}

#calculate the βNTI and RC_bray, this procedure is excessively time consuming. 
#In our study, it spent about half a month to finish this procedure.

#Beta_NTI_bacteria<-Beta_NTI(bacteria.tree, filter.bac.tab)
#Beta_NTI_bacteria_1000 <- as.matrix(Beta_NTI_bacteria)
#write.csv(Beta_NTI_bacteria_1000,"./result/null_model/bacteria.unweighted_bNTI_1000.csv",quote=F);

#Beta_NTI_fungi<-Beta_NTI(fungi.tree, filter.fun.tab)
#Beta_NTI_fungi_1000 <- as.matrix(Beta_NTI_fungi)
#write.csv(Beta_NTI_fungi_1000,"./result/null_model/fungi.unweighted_bNTI_1000.csv",quote=F);

#protist
#Beta_NTI_protists<-Beta_NTI(animal.tree, filter.anim.tab)
#Beta_NTI_protists_1000 <- as.matrix(Beta_NTI_protists)
#write.csv(Beta_NTI_protists_1000,"./result/null_model/protists.unweighted_bNTI_1000.csv",quote=F);

#Beta_NTI_animal<-Beta_NTI(animal.tree, filter.anim.tab)
#Beta_NTI_animal_1000 <- as.matrix(Beta_NTI_animal)
#write.csv(b_NTI_animal_1000,"./result/null_mode/animal.unweighted_bNTI_1000.csv",quote=F);

#calculate the RC_bray
#rcbray_bacteria<-raup_crick(filter.bac.tab)
#rcbray_bacteria_1000<-as.matrix(rcbray_bacteria)
#write.csv(rcbray_bacteria_1000,"./result/null_model/raup_crick_bacteria_1000.csv",quote=F);

#rcbray_fungi<-raup_crick(filter.fun.tab)
#rcbray_fungi_1000<-as.matrix(rcbray_fungi)
#write.csv(rcbray_fungi,"./result/null_model/raup_crick_fungi_1000.csv",quote=F);

#rcbray_protists<-raup_crick(filter.proti.tab)
#rcbray_protists_1000<-as.matrix(rcbray_protists)
#write.csv(rcbray_protists_1000,"./result/null_model/raup_crick_protists_1000.csv",quote=F);

#rcbray_animal<-raup_crick(filter.anim.tab)
#rcbray_animal_1000<-as.matrix(rcbray_animal)
#write.csv(rcbray_animal_1000,"./result/null_model/animal/raup_crick_animal_1000.csv",quote=F);

#read βNTI and RC_bray matrixes
Beta_NTI_bacteria<-read.csv("./result/null_model/bacteria.weighted_bNTI_1000.csv",header=T,row.names=1,stringsAsFactors=F);
rcbray_bacteria<-read.csv("./result/null_model/raup_crick_bacteria_1000.csv",header=T,row.names=1,stringsAsFactors=F);

Beta_NTI_fungi<-read.csv("./result/null_model/fungi.weighted_bNTI_1000.csv",header=T,row.names=1,stringsAsFactors=F);
rcbray_fungi<-read.csv("./result/null_model/raup_crick_fungi_1000.csv",header=T,row.names=1,stringsAsFactors=F);

Beta_NTI_protists<-read.csv("./result/null_model/protist.weighted_bNTI_1000.csv",header=T,row.names=1,stringsAsFactors=F);
rcbray_protists<-read.csv("./result/null_model/raup_crick_protists_1000.csv",header=T,row.names=1,stringsAsFactors=F);

Beta_NTI_animal<-read.csv("./result/null_model/animal.unweighted_bNTI_1000.csv",header=T,row.names=1,stringsAsFactors=F);
rcbray_animal<-read.csv("./result/null_model/raup_crick_animal_1000.csv",header=T,row.names=1,stringsAsFactors=F);

#determine the relative contribution of each process in shaping community
null.index<-function(bNTI.df, rcbray.df){
  bNTI.dist<-as.dist(bNTI.df)
  RC.dist<-as.dist(rcbray.df)
  library(NST)
  null.value<-cbind(dist.3col(bNTI.dist),dist.3col(RC.dist)[3])
  colnames(null.value)<-c('name1','name2','bNTI','RC_bray')
  heterogeneous_selection<-nrow(subset(null.value,bNTI>2))
  homogeneous_selection<-nrow(subset(null.value,bNTI<(-2)))
  dispersal_limitation<-nrow(subset(null.value,bNTI<2 & bNTI>(-2) & RC_bray>0.95))
  homogenizing_dispersal<-nrow(subset(null.value,bNTI<2 & bNTI>(-2) & RC_bray<(-0.95)))
  undominated<-nrow(subset(null.value,bNTI<2 & bNTI>(-2) & RC_bray<0.95 & RC_bray>(-0.95)))
  null.pro<-data.frame(homogeneous_selection,heterogeneous_selection,dispersal_limitation,
                       homogenizing_dispersal,undominated)
  process<-colnames(null.pro)
  Proportion<-as.numeric(null.pro[1,]/sum(null.pro[1,]))
  df<-data.frame(process,Proportion)
  return(df)
}

#determine the relative contribution of each process in shaping community
bacteria.null<-null.index(Beta_NTI_bacteria,rcbray_bacteria)
fungi.null<-null.index(Beta_NTI_fungi,rcbray_fungi)
protists.null<-null.index(Beta_NTI_protists,rcbray_protists)
animal.null<-null.index(Beta_NTI_animal,rcbray_animal)

#transform the wide dataframe to long format
null.3col<-function(bNTI.df){
  bnti_mat <- as.matrix(bNTI.df)
  bNTI.mat<-matrix(0,nrow = 147,ncol = 147)
  bNTI.mat[lower.tri(bNTI.mat)] <- bnti_mat[lower.tri(bnti_mat, diag=TRUE)]
  bNTI.dist<-as.dist(bNTI.df)
  library(NST)
  null.value<-dist.3col(bNTI.dist)
  colnames(null.value)<-c('name1','name2','bNTI')
  return(null.value)
}

bNTI_bacteria<-null.3col(Beta_NTI_bacteria)
bNTI_fungi<-null.3col(Beta_NTI_fungi)
bNTI_protists<-null.3col(Beta_NTI_protists)
bNTI_animal<-null.3col(Beta_NTI_animal)

#density plot of βNTI
#set colors
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
n = 4
cols = gg_color_hue(n)

bNTI_all<-data.frame(taxa=c(rep('Bacteria',nrow(bNTI_bacteria)),
                            rep('Fungi',nrow(bNTI_fungi)),
                            rep('Protists',nrow(bNTI_protists)),
                            rep('Animal',nrow(bNTI_animal))),
                     rbind(bNTI_bacteria,bNTI_fungi,bNTI_protists,bNTI_animal))
bNTI_all$taxa<-factor(bNTI_all$taxa,ordered=T,levels = c('Bacteria','Fungi','Protists','Animal'))
#plot for the frequence distribution of bNTI
bNTI_freq_plot<-ggplot(bNTI_all, aes(bNTI,fill = taxa)) + 
  geom_histogram(color="black",position="identity",bins = 20)+
  facet_wrap( ~taxa, scales='free',ncol = 2) +
  scale_fill_manual(values=c(cols[1],cols[2],cols[3],cols[4]))+
  ylab('Frequency')+xlab('βNTI')+
  theme_bw()+
  theme(axis.title = element_text(size=9),axis.text = element_text(size=7, colour = 'black'),
        strip.text = element_text(size = 9),legend.position='none',panel.grid = element_blank())
bNTI_freq_plot

#pie plot for the proportion of each process
doughnut.plot<-function(data){
  # load library
  library(ggplot2)
  library(dplyr)
  # Compute percentages
  data$process <- factor(data$process, ordered = T, 
                         levels = c('heterogeneous_selection', 'homogeneous_selection',
                                    'dispersal_limitation', 'homogenizing_dispersal', 'undominated'))
  data$Proportion <- round(data$Proportion*100, 2)
  
  count.data <- data %>%
    arrange(desc(process)) %>%
    mutate(lab.ypos = cumsum(Proportion) - 0.5*Proportion)
  mycols <- c("#CD534CFF", "#EFC000FF", "#0073C2FF", "#5d8aa8", '#009E73')
  # Make the plot
  p<-ggplot(count.data, aes(x = 2, y = Proportion, fill = process)) +
    geom_bar(stat = "identity", color = "white") +
    coord_polar(theta = "y", start = 0)+
    geom_text(aes(y = lab.ypos, label = Proportion), color = "black")+
    scale_fill_manual(values = mycols) +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 7))+
    theme_void()+
    xlim(0.5, 2.5)
  return(p)
}

B.doug<-doughnut.plot(bacteria.null)
F.doug<-doughnut.plot(fungi.null)
P.doug<-doughnut.plot(protists.null)
A.doug<-doughnut.plot(animal.null)

library(cowplot)
plot_grid(B.doug,F.doug,P.doug,A.doug,
          labels = "auto", ncol = 2, nrow = 2, label_x = .01, 
          label_y = 1.005,hjust = 0, label_size=17,align = "v")

```